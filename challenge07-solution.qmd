---
title: "Challenge 07 -- Solution"
format:
  html:
    df-print: kable
  # typst:
  #   out-width: 100%
  #   fig-width: 7  # inches
  #   papersiez: a4
  
author: Sebastian Sauer
subtitle: "Datum/Uhrzeit: `r format(Sys.time(), '%Y-%m-%d %H:%M')`"
number-sections: true
toc: true
execute:
  cache: true
---


Betrachten Sie dazu die [Targets-Datei auf Github](https://github.com/sebastiansauer/hans-hackathon2025/blob/main/_targets.R).




# Setup

## Libs
```{r load-libs}
#| include: false
library(tidyverse)
# library(lubridate)
library(gt)  # Tabellen
library(knitr)  # Tabellen
library(tinytable)  # Tabellen
# library(visdat)
# library(data.table)
# library(collapse)
library(targets)
# library(ggstatsplot)
library(easystats)
library(scales)
library(ggpubr)  # Visualisierung
```


## Other setup

```{r setup}
source("_common.r")
list.files("funs", full.names = TRUE) |>
  purrr::walk(source)

options(digits = 3)
options(tinytable_tt_digits = 2)
```


## Load Targets

```{r load-targets}
tar_load(c(
 data_separated_filtered,
 data_separated_filtered_date_uni_course,
 idvisit_has_llm,
 prompt_length,
 prompt_length_date_uni_course,
 n_interactions_w_llm_course_date_course_uni,
 llm_response_text,
 llm_response_text_date_course_uni
))
```


# Musterlösung    

## Auf welche Art und wie oft wird mit dem LLM interagiert? Suchen Sie dafür nach eventcategory "llm" – zählen Sie die Werte der verschiedenen Kategorien. 



```{r}
data_separated_filtered_ai <-
  data_separated_filtered |>
  filter(type == "eventcategory") |>
  filter(str_detect(value, "llm")) |>
  count(value, sort = TRUE) |>
  mutate(prop = n / sum(n))

data_separated_filtered_ai |> 
  kable(digits = 1)
```


Als "Bild-Tabelle":

```{r}
data_separated_filtered_ai |>
  mutate(prop = round(prop, 3)) |>
  ggtexttable()
```

Man beachte das Sortieren der Balken:

```{r}
data_separated_filtered_ai |> 
  ggplot() +
  aes(x = prop, y = value) +
  geom_col()
```


```{r}
data_separated_filtered_ai |> 
  mutate(value = fct_reorder(.f = value, .x = prop)) |> 
  ggplot() +
  aes(x = prop, y = value) +
  geom_col()
```

## Wie viele Nachrichten werden an das LLM gesendet von den Besuchern? 


```{r}
llm_interactions <-
  data_separated_filtered |>
  filter(str_detect(value, "message_to_llm"))
```


Statistiken:

```{r}
llm_interactions_count <-
  llm_interactions |>
  count(idvisit, sort = TRUE) |>
  rename(messages_to_llm_n = n)

llm_interactions_count |>
  describe_distribution(messages_to_llm_n, centrality = c("mean", "median")) |>
  print_md()
```


Man beachte das `print_md`.


```{r}
#| error: true
gghistogram(
  llm_interactions_count,
  x = "Number of messages sent to the LLM",
  y = "Count",
  bins = 10,
  add = "median"
) +
  labs(caption = "The vertical dotted line denotes the median.")
```



## Wie groß ist der Anteil der Besucher, die mit dem LLM interagieren?


Für Tabellen gibt es mehrere Möglichkeiten, z.B. `kable` oder `gt`.

```{r}
data_separated_filtered_llm_interact <-
  data_separated_filtered |>
  mutate(has_llm = str_detect(value, "llm")) |>
  group_by(idvisit) |>
  summarise(llm_used_during_visit = any(has_llm == TRUE)) |>
  count(llm_used_during_visit) |>
  mutate(prop = round(n / sum(n), 2))

data_separated_filtered_llm_interact |>
  gt()
```



Bonus - Auswertung pro `fingerprint`:

```{r}
data_separated_filtered_llm_interact_fingerprint <-
  data_separated_filtered |>
  mutate(has_llm = str_detect(value, "llm")) |>
  group_by(fingerprint) |>
  summarise(llm_used_during_visit = any(has_llm == TRUE)) |>
  count(llm_used_during_visit) |>
  mutate(prop = round(n / sum(n), 2))

data_separated_filtered_llm_interact_fingerprint |>
  gt()
```


## Wie groß ist der Anteil der Besucher, die mit dem LLM interagieren, pro Kunde (Hochschule)?


```{r}
data_separated_filtered_llm_interact_uni <- 
data_separated_filtered_date_uni_course |> 
  mutate(has_llm = str_detect(value, "llm")) |>
  group_by(university, idvisit) |>
  summarise(llm_used_during_visit = any(has_llm == TRUE)) |>
  count(llm_used_during_visit) |>
  mutate(prop = round(n / sum(n), 2)) 
```

### Mit `gt`


```{r}
data_separated_filtered_llm_interact_uni |> 
  gt()
```




### Mit `kable`

```{r}
data_separated_filtered_llm_interact_uni |> 
  kable()
```




### Mit `tinytable`


```{r}
data_separated_filtered_llm_interact_uni |> 
  tt()
```



## Verändert sich der Anteil der Besucher, die mit dem LLM interagieren, im Zeitverlauf?


```{r}
idvisit_has_llm_timeline <-
  idvisit_has_llm |>
  count(year_month, uses_llm) |>
  ungroup() |>
  group_by(year_month) |>
  mutate(prop = round(n / sum(n), 2))

idvisit_has_llm_timeline
```


```{r}
idvisit_has_llm |>
  count(year_month, uses_llm) |>
  ungroup() |>
  mutate(year_month_date = ymd(paste0(year_month, "-01"))) |>
  group_by(year_month_date) |>
  mutate(prop = n / sum(n)) |>
  ggplot(aes(
    x = year_month_date,
    y = prop,
    color = uses_llm,
    groups = uses_llm
  )) +
  # --- Highlight March–July (approx 1 Mar to 31 Jul) ---
  annotate(
    "rect",
    xmin = as.Date("2023-03-01"),
    xmax = as.Date("2023-07-31"),
    ymin = -Inf,
    ymax = Inf,
    alpha = 0.2,
    fill = "skyblue"
  ) +

  annotate(
    "rect",
    xmin = as.Date("2024-03-01"),
    xmax = as.Date("2024-07-31"),
    ymin = -Inf,
    ymax = Inf,
    alpha = 0.2,
    fill = "skyblue"
  ) +
  annotate(
    "rect",
    xmin = as.Date("2025-03-01"),
    xmax = as.Date("2025-07-31"),
    ymin = -Inf,
    ymax = Inf,
    alpha = 0.2,
    fill = "skyblue"
  ) +

  # --- Highlight October–February (semester break or 2nd term) ---
  annotate(
    "rect",
    xmin = as.Date("2023-10-01"),
    xmax = as.Date("2024-02-28"),
    ymin = -Inf,
    ymax = Inf,
    alpha = 0.2,
    fill = "orange"
  ) +
  # annotate("rect",
  #          xmin = as.Date("2024-10-01"), xmax = as.Date("2024-02-28"),
  #          ymin = -Inf, ymax = Inf, alpha = 0.2, fill = "orange") +
  annotate(
    "rect",
    xmin = as.Date("2024-10-01"),
    xmax = as.Date("2025-02-28"),
    ymin = -Inf,
    ymax = Inf,
    alpha = 0.2,
    fill = "orange"
  ) +
  geom_point() +
  geom_line(aes(group = uses_llm)) +
  labs(
    title = "Visitors, die mit dem LLM interagieren im Zeitverlauf (Anteile)"
  ) +
  scale_x_date(breaks = pretty_breaks())
```


[`pretty_breaks`](https://scales.r-lib.org/reference/breaks_pretty.html) sind eine praktische Angelegenheit.


```{r}
idvisit_has_llm |>
  count(year_month, uses_llm) |>
  ungroup() |>
  mutate(year_month_date = ymd(paste0(year_month, "-01"))) |>
  group_by(year_month_date) |>
  # ADDED: Calculate the proportion
  mutate(proportion = n / sum(n)) |>

  # Plot using the new 'proportion' variable
  ggplot(aes(x = year_month_date, y = proportion, fill = uses_llm)) +

  # ADDED: Use position = "fill"
  geom_area(position = "fill") +

  # ADDED: Format y-axis as percentage
  scale_y_continuous(labels = scales::label_percent()) +

  labs(
    title = "Anteil der Besucher, die mit dem LLM interagieren (Prozent)",
    y = "Prozentualer Anteil der Besucher",
    fill = "Interagiert mit LLM",
    x = "Datum"
  ) +
  scale_x_date(breaks = pretty_breaks())
```

## Bonus: Veränderung der LLM-Nutzung im Zeitverlauf


```{r}
# --- 1. Prepare Data ---
# Your original data processing for the plot
plot_data <- n_interactions_w_llm_course_date_course_uni |>
  group_by(floor_date_month) |>
  summarise(n = n()) |>
  ungroup() # Ungroup after summarise for easier use with ggplot

# --- 2. Determine Plot Range for Rectangles ---
# Find the min/max year and n-count from your *processed* plot_data
min_date <- min(plot_data$floor_date_month, na.rm = TRUE)
max_date <- max(plot_data$floor_date_month, na.rm = TRUE)
min_year <- year(min_date)
max_year <- year(max_date)

# Determine the Y-axis bounds for the rectangles
y_min <- min(plot_data$n, na.rm = TRUE)
y_max <- max(plot_data$n, na.rm = TRUE)

# --- 3. Calculate the Rectangle Coordinates (rect_data) ---

# Generate years for the rectangles, ensuring we cover the full range
# including potentially starting a "winter" semester in the min_year-1
# and ending in max_year+1
rect_years <- seq(min_year - 1, max_year + 1)

# Summer semester: March 1 (Y) to July 1 (Y)
summer_rects <- tibble(year = rect_years) |>
  mutate(
    xmin = ymd(paste0(year, "-03-01")),
    xmax = ymd(paste0(year, "-07-01"))
  )

# Winter semester: October 1 (Y) to February 1 (Y+1)
winter_rects <- tibble(year = rect_years) |>
  mutate(
    xmin = ymd(paste0(year, "-10-01")),
    xmax = ymd(paste0(year + 1, "-02-01"))
  )

# Combine, set Y bounds, and filter to the actual plot area
rect_data <- bind_rows(summer_rects, winter_rects) |>
  mutate(ymin = y_min, ymax = y_max) |>
  # Only keep rectangles that are fully or partially within the plot's X range
  filter(
    xmin <= max_date,
    xmax >= min_date
  )

# --- 4. Generate the Final Plot ---
plot_data |>
  ggplot(aes(x = floor_date_month, y = n)) +
  # Add the transparent grey rectangles first
  geom_rect(
    data = rect_data,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
    fill = "grey",
    alpha = 0.2,
    inherit.aes = FALSE # Essential to use the rect_data columns
  ) +
  # Then plot the lines and points on top
  geom_line() +
  geom_point() + # Added point layer for clarity at each month
  theme_minimal() +
  labs(
    title = "Number of Interactions with LLM per Course Date",
    x = "Date",
    y = "Number of Interactions"
  ) 
```






## Die Länge der Prompts an das LLM ist wichtig zu wissen (da potenziell teuer). Werten Sie die Länge der Prompts an das LLM pro Visit aus. Messen Sie die Länge der Prompts in Tokens. 



```{r}
prompt_length_no_prompts <-
  prompt_length |>
  select(-any_of(c("prompt", "value", "type")))
```



```{r}
prompt_length_no_prompts |>
  describe_distribution(token_length) |>
  print_md()
```



```{r}
prompt_length_no_prompts |>
  ggplot(aes(x = token_length)) +
  geom_histogram(binwidth = 5) +
  labs(
    title = "Length of prompts sent to the LLM",
    x = "Prompt length (in tokens)",
    y = "Number of prompts"
  ) +
  theme_minimal()
```

## Unterscheidet sich die Token-Länge zwischen den Kunden (d.h. Hochschulen)?

```{r}
#| warning: false
prompt_length_date_uni_course |>
  group_by(university) |>
  describe_distribution(token_length) |>
  print_md()
```


```{r}
ggboxplot(
  prompt_length_date_uni_course,
  x = "university",
  y = "token_length",
  add = "mean_se",
) +
  theme_minimal() +
  labs(
    title = "Prompt length by university",
    x = "University",
    y = "Prompt length (in tokens)"
  ) +
  coord_flip()
```


## Unterscheidet sich die Token-Länge zwischen den Modulen?



```{r}
#| warning: false
prompt_length_date_uni_course |>
  group_by(course) |>
  describe_distribution(token_length) |>
  print_md()
```



## Unterscheidet sich die Token-Länge im Zeitverlauf?

```{r}
prompt_length_date_uni_course |>
  group_by(floor_date_month) |>
  describe_distribution(token_length) |>
  print_md()
```



```{r}
# Calculate limits properly
filtered_data <- prompt_length_date_uni_course |>
  filter(!is.na(floor_date_month)) |>
  mutate(floor_date_month_date = as.Date(floor_date_month))

lim <- c(
  min(filtered_data$floor_date_month_date, na.rm = TRUE),
  max(filtered_data$floor_date_month_date, na.rm = TRUE)
)

# Now create the plot
filtered_data |>
  ggplot(aes(x = floor_date_month_date, y = token_length)) +
  geom_violin(aes(group = floor_date_month_date)) +
  stat_summary(fun = "mean", geom = "point") +
  stat_summary(fun.data = "mean_se", geom = "errorbar", width = 0.2) +
  theme_minimal() +
  labs(
    title = "Prompt length over time",
    x = "Date",
    y = "Prompt length (in tokens)",
    caption = "The dots represent the mean and the error bars the standard error of the mean."
  ) +
  scale_x_date(limits = lim, labels = scales::label_date_short()) 
```



## Wie oft wird wird auf ein Wort im LLM-Transkript geklickt?


```{r}
data_separated_filtered |>
  filter(type == "subtitle") |>
  # rm empty rows:
  filter(!is.na(value) & value != "") |>
  count(click_transcript_word = str_detect(value, "click_transcript_word")) |>
  mutate(prop = round(n / sum(n), 2)) |>
  gt()
```

## Wie verändert sich dieser Wert im Zeitverlauf?

```{r}
click_transcript_word_per_month <-
  data_separated_filtered |>
  # rm all groups WITHOUT "click_transcript_word":
  group_by(idvisit) |>
  filter(!any(value = str_detect(value, "click_transcript_word"))) |>
  ungroup() |>
  mutate(date_visit = ymd_hms(value)) |>
  mutate(month_visit = floor_date(date_visit, unit = "month")) |>
  drop_na(date_visit) |>
  group_by(idvisit) |>
  slice(1) |>
  ungroup() |>
  count(month_visit)

click_transcript_word_per_month
```



```{r}
rect_data_word_per_month <- comp_semester_rects(
  click_transcript_word_per_month,
  col_date = "month_visit"
)

click_transcript_word_per_month |>
  ggplot(aes(x = month_visit, y = n)) +
  geom_rect(
    data = rect_data,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = Inf),
    fill = "grey",
    alpha = 0.2,
    inherit.aes = FALSE # Essential to use the rect_data columns
  ) +
  geom_line() +
  geom_smooth(method = "loess", se = FALSE, color = "blue", alpha = 0.7) +
  scale_x_date(labels = scales::label_date_short())
```

## Wie lang ist der Output des LLMs (in Tokens)?


### De vs. En

```{r}
llm_response_text |>
  count(lang) |>
  mutate(prob = n / sum(n))
```



### Verteilung der Anzahl der Tokens





```{r}
llm_response_text |>
  describe_distribution(select = "tokens_n") |>
  print_md()
```


## Gruppieren Sie die Länge des Outputs des LLMs nach Kunden (Hochschulen).

```{r}
#| warning: false
llm_response_text_date_course_uni |>
  group_by(university) |>
  describe_distribution(select = "tokens_n")
```



```{r}
llm_response_text_date_course_uni |>
  ggboxplot(
    x = "university",
    y = "tokens_n",
    add = "mean_se"
  ) +
  theme_minimal() +
  labs(
    title = "Number of tokens in LLM responses by university",
    x = "University",
    y = "Number of tokens"
  ) +
  coord_flip()
```


##  Anzahl der Token nach Kursen


```{r}
#| warning: false
llm_response_text_date_course_uni |>
  group_by(course) |>
  describe_distribution(select = "tokens_n") |>
  print_md()
```


```{r}
llm_response_text_date_course_uni |>
  ggboxplot(
    x = "course",
    y = "tokens_n",
    add = "mean_se"
  ) +
  theme_minimal() +
  labs(
    title = "Number of tokens in LLM responses by course",
    x = "Course",
    y = "Number of tokens"
  ) +
  coord_flip()
```



## sessionInfo

```{r}
sessioninfo::session_info()
```


